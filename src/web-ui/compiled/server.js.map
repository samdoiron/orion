{"version":3,"sources":["../server.js"],"names":[],"mappings":";;;;;;oBAqBwB,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WAAP,OAAO","file":"server.js","sourcesContent":["const CONFIG = {\n  webSocketServer: 'ws://localhost:1742',\n  commandFieldSeparator: '\\u001f',\n  connectTimeoutMs: 100\n}\n\nfunction openWebsocket(url) {\n  let connected = m.deferred(),\n    socket = new WebSocket(url)\n\n  socket.onopen = function () {\n    connected.resolve(socket)\n  }\n\n  socket.onerror = function (err) {\n    connected.reject('lol')\n  }\n\n  return connected.promise\n}\n\nexport default function connect() {\n  return openWebsocket(CONFIG.webSocketServer)\n    .then(socket => {\n      let vmInput = new ViewModelInput(socket)\n      let commandOutput = new CommandOutput(socket)\n      return [vmInput, commandOutput]\n    }, () => {\n      let deferred = m.deferred()\n      setTimeout(() => {\n        connect().then(deferred.resolve)\n      }, CONFIG.connectTimeoutMs)\n      return deferred.promise\n    })\n}\n\nclass ViewModelInput {\n  constructor(socket) {\n    this.socket = socket\n    this.socket.onmessage = this._onMessage.bind(this)\n    this.socket.onclose = this._onClose.bind(this)\n\n    this.onUpdateCallbacks = []\n    this.onCloseCallbacks = []\n    this.onErrorCallbacks = []\n    this.lastVm = null;\n  }\n\n  onUpdate(callback) {\n    this.onUpdateCallbacks.push(callback)\n\n    // Sometimes we attach the initial update handler AFTER the first\n    // VM has been sent, meaning the view wouldn't be rendered initially.\n    if (this.lastVm) {\n      callback(lastVm)\n    }\n  }\n\n  onClose(callback) {\n    this.onCloseCallbacks.push(callback)\n  }\n\n  onError(callback) {\n    this.onErrorCallbacks.push(callback)\n  }\n\n  _onMessage(message) {\n    m.startComputation();\n    let vm = JSON.parse(message.data)\n    this.lastVm = vm\n    console.log('%c VM', 'color: green', vm)\n    this.onUpdateCallbacks.forEach(x => x(vm))\n    m.endComputation()\n  }\n\n  _onClose() {\n    m.startComputation();\n    this.onCloseCallbacks.forEach(x => x())\n    m.endComputation();\n  }\n}\n\nclass CommandOutput {\n  constructor(socket) {\n    this.socket = socket;\n  }\n\n  createHistogram(name) {\n    this._sendDoCommand('CreateHistogram', [name])\n  }\n\n  _sendDoCommand(commandName, args) {\n    this.socket.send(this._encodeDoCommand(commandName, args))\n    console.log('%c COMMAND', 'color: hotpink', commandName, args)\n  }\n\n  _encodeDoCommand(commandName, args) {\n    return ['do', commandName].concat(args).join(CONFIG.commandFieldSeparator)\n  }\n}\n\n"]}